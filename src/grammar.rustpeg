use ast::*;
use typechecker::ConstraintType;

pub program -> Vec<StmtNode>
    = __ terminators? s:statements { s }

pub statements -> Vec<StmtNode>
    = statement_node*

statement_node -> StmtNode
    = lpos:#position s:statement rpos:#position { StmtNode { pos: (lpos, rpos), data: s } }

statement -> Stmt
    = s:if_statement { s }
    / l:loop_statement { l }
    / BREAK TERMINATOR { Stmt::Break }
    / RETURN e:expr_node? TERMINATOR { Stmt::Return(e) }
    / a:assignment_statement { a }
    / v:variable_declaration { v }
    / e:expr_node TERMINATOR { Stmt::Expr(e) }
    / f:function_definition_node { Stmt::Expr(f) }
    / b:block { b }
    / TERMINATOR { Stmt::Empty }

assignment_statement -> Stmt
    = lpos:#position i:identifier rpos:#position EQUALS e:expr_node TERMINATOR {
        Stmt::Assign(LhsExprNode { pos: (lpos, rpos), data: LhsExpr::Identifier(i) }, e)
    }

variable_declaration -> Stmt
    = b:binding_type i:identifier EQUALS e:expr_node TERMINATOR {
        Stmt::VarDecl(
            Variable::Identifier(b, i), e
        )
     }

binding_type -> BindingType
    = VAR { BindingType::Mutable }

loop_statement -> Stmt
    = LOOP lpos:#position b:block rpos:#position { Stmt::Loop(Box::new(StmtNode { pos: (lpos, rpos), data: b })) }

if_statement -> Stmt
    = IF e:expr_node lpos1:#position b1:block rpos1:#position ELSE lpos2:#position b2:block rpos2:#position {
        Stmt::IfThenElse(
            e,
            Box::new(StmtNode { pos: (lpos1, rpos1), data: b1 }),
            Box::new(StmtNode { pos: (lpos2, rpos2), data: b2 }),
        )
    }
    / IF e:expr_node lpos:#position b:block rpos:#position { Stmt::IfThen(e, Box::new(StmtNode { pos: (lpos, rpos), data: b })) }

block -> Stmt
    = #quiet<_block> / #expected("block")

_block -> Stmt
    = OPENING_BRACE terminators? s:statements terminators? CLOSING_BRACE { Stmt::Block(s) }

function_definition_node -> ExprNode
    = lpos:#position f:function_definition rpos:#position { ExprNode { pos: (lpos, rpos), data: f } }

function_definition -> Expr
    = FN i:identifier? OPEN_PAREN params:param_list COMMA? CLOSE_PAREN maybe_ret_hint:return_type_hint? lpos:#position body:block rpos:#position {
        let return_type = match maybe_ret_hint {
            Some(ret_hint) => ret_hint,
            None => Some(ConstraintType::Any),
        };
        Expr::FnDef(
            i,
            params,
            Box::new(StmtNode { pos: (lpos, rpos), data: body } ),
            return_type,
        )
    }

param_list -> Vec<(String, Option<ConstraintType>)>
    = identifier_with_possible_type ** COMMA

identifier_with_possible_type -> (String, Option<ConstraintType>)
    = id:identifier t:type_hint? { (id, t) }

return_type_hint -> Option<ConstraintType>
    = COLON VOID { None }
    / COLON t:typ { Some(t) }

type_hint -> ConstraintType
    = COLON t:typ { t }

typ -> ConstraintType
    = NUMBER { ConstraintType::Number }
    / BOOL { ConstraintType::Bool }
    / STRING { ConstraintType::String }
    / FUNCTION { ConstraintType::Function }
    / TUPLE { ConstraintType::Tuple }
    / ANY { ConstraintType::Any }

expr_node -> ExprNode
    = e:binary_expr_node { e }
    / s:single_expr_node { s }

comma_args -> Vec<ExprNode>
    = expr_node ** COMMA

binary_expr_node -> ExprNode
    = lpos:#position e:binary_expr rpos:#position { ExprNode { pos: (lpos, rpos), data: e.data } }

binary_expr -> ExprNode = #infix<single_expr_node> {
    #L x AND y { ExprNode { pos: (0, 0), data: Expr::BinaryLogical(Box::new(x), LogicalBinOp::And, Box::new(y)) } }
       x OR y { ExprNode { pos: (0, 0), data: Expr::BinaryLogical(Box::new(x), LogicalBinOp::Or, Box::new(y)) } }
    #L x OP_STRICT_EQUALS y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Eq, Box::new(y)) } }
    #L x OP_LESS_THAN y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Lt, Box::new(y)) } }
       x OP_LESS_THAN_OR_EQUAL y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Lte, Box::new(y)) } }
       x OP_GREATER_THAN y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Gt, Box::new(y)) } }
       x OP_GREATER_THAN_OR_EQUAL y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Gte, Box::new(y)) } }
    #L x OP_PLUS y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Add, Box::new(y)) } }
       x OP_MINUS y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Sub, Box::new(y)) } }
    #L x OP_ASTERISK y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Mul, Box::new(y)) } }
       x OP_SLASH y { ExprNode { pos: (0, 0), data: Expr::Binary(Box::new(x), BinOp::Div, Box::new(y)) } }
}

single_expr_node -> ExprNode
    = OPEN_PAREN e:expr_node CLOSE_PAREN { e }
    / e:expr_with_suffix { e }

expr_with_suffix -> ExprNode
    // TODO: This sort of messes up position annotation for the ExprNode
    = lpos:#position e:simple_expr_node suffixes:expr_suffix* rpos:#position {
        if suffixes.is_empty() {
            e
        } else {
            let mut expr = e;
            for suffix in suffixes {
                match suffix {
                    ExprSuffix::InSquareBrackets(idx_expr) => {
                        expr = ExprNode {
                            pos: (lpos, rpos),
                            data: Expr::MemberByIdx(Box::new(expr), Box::new(idx_expr)),
                        }
                    }
                    ExprSuffix::ListInParens(args_list) => {
                        expr = ExprNode {
                            pos: (lpos, rpos),
                            data: Expr::FnCall(Box::new(expr), args_list),
                        }
                    }
                }
            }
            expr
        }
    }

expr_suffix -> ExprSuffix
    = member_access_suffix
    / function_call_suffix

member_access_suffix -> ExprSuffix
    = OPEN_SQUARE_BRACKET idx:expr_node CLOSE_SQUARE_BRACKET { ExprSuffix::InSquareBrackets(idx) }

function_call_suffix -> ExprSuffix
    = OPEN_PAREN args:comma_args COMMA? CLOSE_PAREN { ExprSuffix::ListInParens(args) }

simple_expr_node -> ExprNode
    = lpos:#position e:simple_expr rpos:#position { ExprNode { pos: (lpos, rpos), data: e } }

simple_expr -> Expr
    = OP_MINUS e:single_expr_node { Expr::Unary(UnOp::Neg, Box::new(e)) }
    / NOT e:expr_node { Expr::UnaryLogical(LogicalUnOp::Not, Box::new(e)) }
    / t:tuple { t }
    / f:function_definition { f }
    / l:literal_node { Expr::Literal(l) }
    / i:identifier { Expr::Identifier(i) }

literal_node -> LiteralNode
    = lpos:#position l:literal rpos:#position {
        LiteralNode { pos: (lpos, rpos), data: l }
    }

literal -> Literal
    = f:float { Literal::Float(f) }
    / i:integer { Literal::Integer(i) }
    / b:boolean { Literal::Bool(b) }
    / s:doubleQuotedString { Literal::String(s) }

tuple -> Expr
    = #quiet<_tuple> / #expected("tuple")

_tuple -> Expr
    = OPEN_PAREN args:comma_args COMMA? CLOSE_PAREN {
        Expr::Tuple(args)
    }

doubleQuotedString -> String
    = #quiet<_doubleQuotedString> / #expected("string")

_doubleQuotedString -> String
    = '"' s:$([^"]*) '"' __ { s.to_owned() }

integer -> i64
    = #quiet<_integer> / #expected("number")

_integer -> i64
    = n:$([+-]?[0-9]+) __ { n.parse().unwrap() }

float -> f64
    = #quiet<_float> / #expected("number")

_float -> f64
    = f:$([+-]?[0-9]+"."[0-9]+) __ { f.parse().unwrap() }

boolean -> bool
    = #quiet<_boolean> / #expected("bool")

_boolean -> bool
    = "true" __ { true }
    / "false" __ { false }

identifier -> String
    = #quiet<_identifier> / #expected("identifier")

_identifier -> String
    = !reserved_identifier i:$([a-zA-Z_][a-zA-Z0-9_]*[!?]?) __ { i.to_string() }

__ = whitespace*

whitespace = #quiet<[ \t\n]>

EQUALS = #quiet<"=" __> / #expected("equals")

terminators = TERMINATOR+

TERMINATOR -> ()
    = ";" __

OP_PLUS = "+" __
OP_MINUS = "-" __
OP_ASTERISK = "*" __
OP_SLASH = "/" __
OP_COLON = ":" __
OP_LESS_THAN = "<" __
OP_GREATER_THAN = ">" __
OP_LESS_THAN_OR_EQUAL = "<=" __
OP_GREATER_THAN_OR_EQUAL = ">=" __

OP_STRICT_EQUALS = "==" __

OPENING_BRACE = "{" __
CLOSING_BRACE = "}" __
OPEN_PAREN = "(" __
CLOSE_PAREN = ")" __
OPEN_SQUARE_BRACKET = "[" __
CLOSE_SQUARE_BRACKET = "]" __

COMMA = "," __
COLON = ":" __

reserved_identifier = VAR
                    / IF
                    / ELSE
                    / AND
                    / OR
                    / NOT
                    / "true"
                    / "false"
                    / LOOP
                    / BREAK
                    / FN
                    / RETURN;

keyword<E> = E __

VAR = keyword<"var">
IF = keyword<"if">
ELSE = keyword<"else">
AND = keyword<"and">
OR = keyword<"or">
NOT = keyword<"not">
LOOP = keyword<"loop">
BREAK = keyword<"break">
FN = keyword<"fn">
RETURN = keyword<"return">
NUMBER = keyword<"Number">
BOOL = keyword<"Bool">
STRING = keyword<"String">
FUNCTION = keyword<"Function">
TUPLE = keyword<"Tuple">
ANY = keyword<"any">
VOID = keyword<"void">
